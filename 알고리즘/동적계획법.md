# 동적 계획법 (Dynamic Programming)

## 예제

### 피보나치 수 구하기

```java
/**
 * 
 * Fn = Fn-1 + Fn-2
 * F0 = 1, F1 = 1
 * F2 = F1 + F0
 * F3 = F2 + F1
 * ...
 */
```

* 분할정복법을 이용한 풀이가 아님
    * 문제를 독립적으로 나누지 않았기 때문
* 작은 "나"를 해결할 결과를 계속해서 써먹는다.
    * F(n)을 알기 위해서는 F(n) ~ F(n - 1)을 모두 알아야함
* **<span style="color:#F7CE46">"나" 보다 작은 모든 풀이를 먼저 기억하자</span>**
    * F(n)을 구하기 전에 F(1) ~ F(n - 1)을 모두 구하자.
    * ex) F(6) = F(1) F(2) F(3) F(4) F(5) 차례대로 구하자.
    
> **분할 정복법**: 큰 문제를 쪼개 내려오는것 (Top down)

> **동적 계획법**: 밑 에서 올라가는 것 (Bottom up)

### 동적 계획법의 문제 풀이 순서

1. 부분 문제(소문제)를 <span style="color:#F7CE46">말로</span> 정의한다.
    * <span style="color:#285FF4"> 무슨 값을 구할지를 정의한다.</span>
2. 점화식을 구한다.
    * <span style="color:#285FF4">그 값을 어떻게 구할지에 대한 식을 세운다.</span>
    * <span style="color:#F7CE46">부분을 풀려있다고 가정</span>
3. 문제를 해결한다.
    * <span style="color:#285FF4">값을 직접 구하는 코드를 작성한다.</span>
    
### 피보나치 수 구하기
1. 부분 문제를 정의한다.
    * 무슨 값을 구할지를 정의한다.
    * 부분문제 : F(i) = F<sub>i</sub>의 값
2. 점화식을 구한다.
    * 그 값을 어떻게 구할지에 대한 식을 세운다. <span style="color:#285FF4">F(i) = F<sub>i</sub>의 값</span>
    * <span style="color:#F7CE46">부분문제/소문제는 풀려있다고 가정</span>
    * F<sub>5</sub> = F<sub>1</sub> F<sub>2</sub> F<sub>3</sub> F<sub>4</sub>가 구해진 상태
    * F(i) = F(i - 1) + F(i - 2)
3. 문제를 해결한다.
    * 값을 직접 구하는 코드를 작성한다.

```java
import java.util.Scanner;
public class Main {
    static int n;
    static int[] data;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        data = new int[n + 10];
        data[0] = 1;
        data[1] = 1;
        System.out.println(getFibonacci(2));
    }

    static int getFibonacci(int x) {
        if(x >= n) {
            return data[x - 1];
        } else {
            data[x] = data[x - 1] + data[x - 2];
            return getFibonacci(x + 1);
        }
    }
}
```

> 핵심 = 전체경우를 어찌 적당히 나눠서 풀 것인가..
> 
> //T(i) = 2 x i
//T(2) = 2
//T(3) = 3?

        //T(i - 1) = 2 * (i - 1)
        //T(i - 2) = 2 * (i - 2)
        //T(i) = T(i - 1) + (T - 2) = 피보나치 수열..
